


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > AbstractSyntaxTreeFactory</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">ast</a>
</div>

<h1>Coverage Summary for Class: AbstractSyntaxTreeFactory (ast)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">AbstractSyntaxTreeFactory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (20/20)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    87,5%
  </span>
  <span class="absValue">
    (182/208)
  </span>
</td>
</tr>
  <tr>
    <td class="name">AbstractSyntaxTreeFactory$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (21/21)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    87,6%
  </span>
  <span class="absValue">
    (183/209)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package ast;
&nbsp;
&nbsp;import static parser.Constants.ASSIGNMENT_EXPRESSION;
&nbsp;import static parser.Constants.ASSIGNMENT_IDENTIFIER;
&nbsp;import static parser.Constants.DECLARATION_TYPE;
&nbsp;import static parser.Constants.DECLARERATION_EXPRESSION;
&nbsp;import static parser.Constants.DECLARERATION_IDENTIFIER;
&nbsp;import static parser.Constants.EMPTY_BLOCK_SIZE;
&nbsp;import static parser.Constants.FIRST_OPERAND;
&nbsp;import static parser.Constants.IF_EXPRESSION;
&nbsp;import static parser.Constants.IF_STATEMENT;
&nbsp;import static parser.Constants.OPERATOR;
&nbsp;import static parser.Constants.PRIMARY_EXPRESSION;
&nbsp;import static parser.Constants.PRIMARY_VALUE;
&nbsp;import static parser.Constants.SECOND_OPERAND;
&nbsp;import static parser.Constants.STATEMENT_TYPE;
&nbsp;import static parser.Constants.UNARY;
&nbsp;import static parser.Constants.UNARY_OPERATOR;
&nbsp;import static parser.Constants.WHILE_EXPRESSION;
&nbsp;
&nbsp;import error.CompileError;
&nbsp;import error.UnexpectedError;
&nbsp;import lexer.Token;
&nbsp;import lexer.TokenKind;
&nbsp;import parser.ParseTree;
&nbsp;import types.*;
&nbsp;
&nbsp;public class AbstractSyntaxTreeFactory {
&nbsp;  public AbstractSyntaxTree ast;
&nbsp;  public SymbolTable symbolTable;
&nbsp;
<b class="fc">&nbsp;  public AbstractSyntaxTreeFactory() {</b>
<b class="fc">&nbsp;    ast = new AbstractSyntaxTree(AstNodeKinds.PROGRAM, Type.tVoid(), 0, 0);</b>
<b class="fc">&nbsp;    symbolTable = new SymbolTable();</b>
<b class="fc">&nbsp;    symbolTable.initStd();</b>
&nbsp;  }
&nbsp;
&nbsp;  public AbstractSyntaxTree fromParseTree(ParseTree st) throws CompileError {
<b class="fc">&nbsp;    processProgram(st, ast, symbolTable);</b>
<b class="fc">&nbsp;    ast.checkTypes();</b>
<b class="fc">&nbsp;    return ast;</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Handle a declaration, this isn&#39;t a non terminal of the grammar, but is
&nbsp;   * implicit
&nbsp;   * 
&nbsp;   * @param ast
&nbsp;   * @param pt
&nbsp;   * @param sTable
&nbsp;   */
&nbsp;  void declaration(AbstractSyntaxTree ast, ParseTree pt, SymbolTable sTable) throws CompileError {
<b class="fc">&nbsp;    Token t = pt.getChild(DECLARERATION_IDENTIFIER).token;</b>
<b class="fc">&nbsp;    String ident = t.lexem;</b>
<b class="fc">&nbsp;    if (sTable.has(ident)) {</b>
<b class="nc">&nbsp;      throw new IndentifierAlreadyDeclaredError(ident, t.line, t.linePos);</b>
&nbsp;    }
<b class="fc">&nbsp;    Type type = new Type(Types.VAR);</b>
<b class="fc">&nbsp;    Token declarationType = pt.getChild(DECLARATION_TYPE).token;</b>
<b class="fc">&nbsp;    switch (declarationType.lexem) {</b>
&nbsp;      case &quot;int&quot;:
<b class="fc">&nbsp;        type.setRetType(Types.INTEGER);</b>
<b class="fc">&nbsp;        break;</b>
&nbsp;      case &quot;bool&quot;:
<b class="fc">&nbsp;        type.setRetType(Types.BOOLEAN);</b>
<b class="fc">&nbsp;        break;</b>
&nbsp;
&nbsp;      default:
<b class="nc">&nbsp;        throw new UnexpectedError(&quot;Every declaration should have a type&quot;, declarationType.line,</b>
&nbsp;            declarationType.linePos);
&nbsp;    }
<b class="fc">&nbsp;    int adress = sTable.insert(ident, type);</b>
<b class="fc">&nbsp;    ast.insertSubTree(AstNodeKinds.IDENT, type, t.line, t.linePos, ident);</b>
<b class="fc">&nbsp;    ast.insertSubTree(AstNodeKinds.ADDRESS, new Type(Types.MEMORY_ADDRESS, Types.MEMORY_ADDRESS), t.line, t.linePos,</b>
&nbsp;        &quot;&quot; + adress);
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Handle an assignment, this isn&#39;t a non terminal of the grammar, but is
&nbsp;   * implicit
&nbsp;   * 
&nbsp;   * @param ast
&nbsp;   * @param pt
&nbsp;   * @param sTable
&nbsp;   * @throws CompileError
&nbsp;   */
&nbsp;  void assignment(AbstractSyntaxTree ast, ParseTree pt, SymbolTable sTable) throws CompileError {
<b class="fc">&nbsp;    ParseTree ident = pt.getChild(ASSIGNMENT_IDENTIFIER);</b>
<b class="fc">&nbsp;    Symbol s = sTable.get(ident.token.lexem);</b>
<b class="fc">&nbsp;    if (s == null) {</b>
<b class="nc">&nbsp;      throw new UnknownIdentifierError(ident.token.lexem, ident.token.line, ident.token.linePos);</b>
&nbsp;    }
<b class="fc">&nbsp;    ast.type = new Type(s.getType().getRetType());</b>
&nbsp;    // insert ident child
<b class="fc">&nbsp;    ast.insertSubTree(AstNodeKinds.IDENT, new Type(Types.VAR, s.getType().getRetType()), ident.token.line,</b>
&nbsp;        ident.token.linePos,
&nbsp;        ident.token.lexem);
&nbsp;    // handle expression
<b class="fc">&nbsp;    expression(ast, pt.getChild(ASSIGNMENT_EXPRESSION), sTable);</b>
&nbsp;  }
&nbsp;
&nbsp;  void expression(AbstractSyntaxTree ast, ParseTree pt, SymbolTable sTable) throws CompileError {
&nbsp;
<b class="fc">&nbsp;    if (!isChildCount1or3(pt)) {</b>
<b class="nc">&nbsp;      throw new Error(&quot;Invalid Expression child count: &quot; + pt.getChildCount());</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    if (pt.getChildCount() == 1) {</b>
<b class="fc">&nbsp;      equality(ast, pt.getChild(FIRST_OPERAND), sTable);</b>
&nbsp;    } else {
&nbsp;      AbstractSyntaxTree tmp;
<b class="fc">&nbsp;      ParseTree op = pt.getChild(OPERATOR);</b>
<b class="fc">&nbsp;      switch (pt.getChild(OPERATOR).getKind()) {</b>
&nbsp;        case LAND:
<b class="fc">&nbsp;          tmp = ast.insertSubTree(AstNodeKinds.LAND, new Type(Types.BOOLEAN, Types.BOOLEAN), op.token.line,</b>
&nbsp;              op.token.linePos);
&nbsp;
<b class="fc">&nbsp;          break;</b>
&nbsp;
&nbsp;        case LOR:
<b class="fc">&nbsp;          tmp = ast.insertSubTree(AstNodeKinds.LOR, new Type(Types.BOOLEAN, Types.BOOLEAN), op.token.line,</b>
&nbsp;              op.token.linePos);
&nbsp;
<b class="fc">&nbsp;          break;</b>
&nbsp;
&nbsp;        case OR:
<b class="nc">&nbsp;          tmp = ast.insertSubTree(AstNodeKinds.OR, new Type(Types.INTEGER, Types.INTEGER), op.token.line,</b>
&nbsp;              op.token.linePos);
&nbsp;
<b class="nc">&nbsp;          break;</b>
&nbsp;
&nbsp;        case AND:
<b class="fc">&nbsp;          tmp = ast.insertSubTree(AstNodeKinds.AND, new Type(Types.INTEGER, Types.INTEGER), op.token.line,</b>
&nbsp;              op.token.linePos);
<b class="fc">&nbsp;          break;</b>
&nbsp;
&nbsp;        default:
<b class="nc">&nbsp;          throw new UnexpectedError(&quot;ParseTree malformed, Operator &quot; + op.token.lexem, op.token.line, op.token.linePos);</b>
&nbsp;      }
<b class="fc">&nbsp;      equality(tmp, pt.getChild(FIRST_OPERAND), sTable);</b>
<b class="fc">&nbsp;      expression(tmp, pt.getChild(SECOND_OPERAND), sTable);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  void equality(AbstractSyntaxTree ast, ParseTree pt, SymbolTable sTable) throws CompileError {
<b class="fc">&nbsp;    if (!isChildCount1or3(pt)) {</b>
<b class="nc">&nbsp;      throw new Error(&quot;Invalid Expression child count: &quot; + pt.getChildCount());</b>
&nbsp;    }
<b class="fc">&nbsp;    if (pt.getChildCount() == 1) {</b>
<b class="fc">&nbsp;      comparision(ast, pt.getChild(FIRST_OPERAND), sTable);</b>
&nbsp;    } else {
&nbsp;      AbstractSyntaxTree tmp;
<b class="fc">&nbsp;      ParseTree op = pt.getChild(OPERATOR);</b>
<b class="fc">&nbsp;      switch (op.getKind()) {</b>
&nbsp;        case NOTEQ:
<b class="fc">&nbsp;          tmp = ast.insertSubTree(AstNodeKinds.NOTEQ, new Type(Types.UNKNOWN, Types.BOOLEAN), op.token.line,</b>
&nbsp;              op.token.linePos);
&nbsp;
<b class="fc">&nbsp;          break;</b>
&nbsp;        case EQEQ:
<b class="fc">&nbsp;          tmp = ast.insertSubTree(AstNodeKinds.EQEQ, new Type(Types.UNKNOWN, Types.BOOLEAN), op.token.line,</b>
&nbsp;              op.token.linePos);
&nbsp;
<b class="fc">&nbsp;          break;</b>
&nbsp;
&nbsp;        default:
<b class="nc">&nbsp;          throw new UnexpectedError(&quot;ParseTree malformed, Operator: &quot; + op.token.lexem, op.token.line,</b>
&nbsp;              op.token.linePos);
&nbsp;      }
<b class="fc">&nbsp;      comparision(tmp, pt.getChild(FIRST_OPERAND), sTable);</b>
<b class="fc">&nbsp;      equality(tmp, pt.getChild(SECOND_OPERAND), sTable);</b>
&nbsp;    }
&nbsp;
&nbsp;  }
&nbsp;
&nbsp;  void comparision(AbstractSyntaxTree ast, ParseTree pt, SymbolTable sTable) throws CompileError {
<b class="fc">&nbsp;    if (!isChildCount1or3(pt)) {</b>
<b class="nc">&nbsp;      throw new Error(&quot;Invalid Expression child count: &quot; + pt.getChildCount());</b>
&nbsp;    }
<b class="fc">&nbsp;    if (pt.getChildCount() == 1) {</b>
<b class="fc">&nbsp;      arithmeticExpr(ast, pt.getChild(FIRST_OPERAND), sTable);</b>
&nbsp;    } else {
&nbsp;      AbstractSyntaxTree tmp;
<b class="fc">&nbsp;      ParseTree op = pt.getChild(OPERATOR);</b>
<b class="fc">&nbsp;      switch (op.getKind()) {</b>
&nbsp;        case LT:
<b class="fc">&nbsp;          tmp = ast.insertSubTree(AstNodeKinds.LT, new Type(Types.INTEGER, Types.BOOLEAN), op.token.line,</b>
&nbsp;              op.token.linePos);
&nbsp;
<b class="fc">&nbsp;          break;</b>
&nbsp;        case LTEQ:
<b class="fc">&nbsp;          tmp = ast.insertSubTree(AstNodeKinds.LTEQ, new Type(Types.INTEGER, Types.BOOLEAN), op.token.line,</b>
&nbsp;              op.token.linePos);
&nbsp;
<b class="fc">&nbsp;          break;</b>
&nbsp;        case GT:
<b class="nc">&nbsp;          tmp = ast.insertSubTree(AstNodeKinds.GT, new Type(Types.INTEGER, Types.BOOLEAN), op.token.line,</b>
&nbsp;              op.token.linePos);
&nbsp;
<b class="nc">&nbsp;          break;</b>
&nbsp;        case GTEQ:
<b class="fc">&nbsp;          tmp = ast.insertSubTree(AstNodeKinds.GTEQ, new Type(Types.INTEGER, Types.BOOLEAN), op.token.line,</b>
&nbsp;              op.token.linePos);
&nbsp;
<b class="fc">&nbsp;          break;</b>
&nbsp;
&nbsp;        default:
<b class="nc">&nbsp;          throw new UnexpectedError(&quot;ParseTree malformed, Operator: &quot; + op.token.lexem, op.token.line,</b>
&nbsp;              op.token.linePos);
&nbsp;      }
<b class="fc">&nbsp;      arithmeticExpr(tmp, pt.getChild(FIRST_OPERAND), sTable);</b>
<b class="fc">&nbsp;      comparision(tmp, pt.getChild(SECOND_OPERAND), sTable);</b>
&nbsp;
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  void arithmeticExpr(AbstractSyntaxTree ast, ParseTree pt, SymbolTable sTable) throws CompileError {
<b class="fc">&nbsp;    if (!isChildCount1or3(pt)) {</b>
<b class="nc">&nbsp;      throw new Error(&quot;Invalid Expression child count: &quot; + pt.getChildCount());</b>
&nbsp;    }
<b class="fc">&nbsp;    if (pt.getChildCount() == 1) {</b>
<b class="fc">&nbsp;      term(ast, pt.getChild(FIRST_OPERAND), sTable);</b>
&nbsp;    } else {
&nbsp;      AbstractSyntaxTree tmp;
<b class="fc">&nbsp;      ParseTree op = pt.getChild(OPERATOR);</b>
<b class="fc">&nbsp;      switch (op.getKind()) {</b>
&nbsp;        case PLUS:
<b class="fc">&nbsp;          tmp = ast.insertSubTree(AstNodeKinds.PLUS, new Type(Types.INTEGER, Types.INTEGER), op.token.line,</b>
&nbsp;              op.token.linePos);
&nbsp;
<b class="fc">&nbsp;          break;</b>
&nbsp;        case MINUS:
<b class="fc">&nbsp;          tmp = ast.insertSubTree(AstNodeKinds.MINUS, new Type(Types.INTEGER, Types.INTEGER), op.token.line,</b>
&nbsp;              op.token.linePos);
&nbsp;
<b class="fc">&nbsp;          break;</b>
&nbsp;
&nbsp;        default:
<b class="nc">&nbsp;          throw new UnexpectedError(&quot;ParseTree malformed, Operator: &quot; + op.token.lexem, op.token.line,</b>
&nbsp;              op.token.linePos);
&nbsp;      }
<b class="fc">&nbsp;      term(tmp, pt.getChild(FIRST_OPERAND), sTable);</b>
<b class="fc">&nbsp;      arithmeticExpr(tmp, pt.getChild(SECOND_OPERAND), sTable);</b>
&nbsp;
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  void term(AbstractSyntaxTree ast, ParseTree pt, SymbolTable sTable) throws CompileError {
<b class="fc">&nbsp;    if (!isChildCount1or3(pt)) {</b>
<b class="nc">&nbsp;      throw new Error(&quot;Invalid Expression child count: &quot; + pt.getChildCount());</b>
&nbsp;    }
<b class="fc">&nbsp;    if (pt.getChildCount() == 1) {</b>
<b class="fc">&nbsp;      unary(ast, pt.getChild(FIRST_OPERAND), sTable);</b>
&nbsp;    } else {
&nbsp;      AbstractSyntaxTree tmp;
<b class="fc">&nbsp;      ParseTree op = pt.getChild(OPERATOR);</b>
<b class="fc">&nbsp;      switch (op.getKind()) {</b>
&nbsp;        case ASTERISK:
<b class="fc">&nbsp;          tmp = ast.insertSubTree(AstNodeKinds.MUL, new Type(Types.INTEGER, Types.INTEGER), op.token.line,</b>
&nbsp;              op.token.linePos);
&nbsp;
<b class="fc">&nbsp;          break;</b>
&nbsp;        case SLASH:
<b class="fc">&nbsp;          tmp = ast.insertSubTree(AstNodeKinds.DIV, new Type(Types.INTEGER, Types.INTEGER), op.token.line,</b>
&nbsp;              op.token.linePos);
&nbsp;
<b class="fc">&nbsp;          break;</b>
&nbsp;        case PERCENT:
<b class="fc">&nbsp;          tmp = ast.insertSubTree(AstNodeKinds.MOD, new Type(Types.INTEGER, Types.INTEGER), op.token.line,</b>
&nbsp;              op.token.linePos);
&nbsp;
<b class="fc">&nbsp;          break;</b>
&nbsp;
&nbsp;        default:
<b class="nc">&nbsp;          throw new UnexpectedError(&quot;ParseTree malformed, Operator: &quot; + op.token.lexem, op.token.line,</b>
&nbsp;              op.token.linePos);
&nbsp;      }
<b class="fc">&nbsp;      unary(tmp, pt.getChild(FIRST_OPERAND), sTable);</b>
<b class="fc">&nbsp;      term(tmp, pt.getChild(SECOND_OPERAND), sTable);</b>
&nbsp;
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  void unary(AbstractSyntaxTree ast, ParseTree pt, SymbolTable sTable) throws CompileError {
<b class="fc">&nbsp;    if (pt.getChildCount() != 1 &amp;&amp; pt.getChildCount() != 2) {</b>
<b class="nc">&nbsp;      throw new Error(&quot;Invalid Expression child count: &quot; + pt.getChildCount());</b>
&nbsp;    }
<b class="fc">&nbsp;    if (pt.getChildCount() == 1) {</b>
<b class="fc">&nbsp;      primary(ast, pt.getChild(FIRST_OPERAND), sTable);</b>
&nbsp;    } else {
<b class="fc">&nbsp;      ParseTree op = pt.getChild(UNARY_OPERATOR);</b>
<b class="fc">&nbsp;      switch (op.getKind()) {</b>
&nbsp;        case NOT:
<b class="fc">&nbsp;          unary(</b>
<b class="fc">&nbsp;              ast.insertSubTree(AstNodeKinds.NOT, new Type(Types.UNKNOWN, Types.UNKNOWN), op.token.line,</b>
&nbsp;                  op.token.linePos),
<b class="fc">&nbsp;              pt.getChild(UNARY), sTable);</b>
&nbsp;
<b class="fc">&nbsp;          break;</b>
&nbsp;        case MINUS:
<b class="fc">&nbsp;          unary(</b>
<b class="fc">&nbsp;              ast.insertSubTree(AstNodeKinds.NEG, new Type(Types.INTEGER, Types.INTEGER), op.token.line,</b>
&nbsp;                  op.token.linePos),
<b class="fc">&nbsp;              pt.getChild(UNARY),</b>
&nbsp;              sTable);
&nbsp;
<b class="fc">&nbsp;          break;</b>
&nbsp;
&nbsp;        default:
<b class="nc">&nbsp;          throw new UnexpectedError(&quot;ParseTree malformed, Operator: &quot; + op.token.lexem, op.token.line,</b>
&nbsp;              op.token.linePos);
&nbsp;      }
&nbsp;
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  void primary(AbstractSyntaxTree ast, ParseTree pt, SymbolTable sTable) throws CompileError {
<b class="fc">&nbsp;    int childCount = pt.getChildCount();</b>
<b class="fc">&nbsp;    if (childCount &lt; 1 || childCount &gt; 3) {</b>
<b class="nc">&nbsp;      throw new UnexpectedError(&quot;ParseTree malformed, Childcount: &quot; + childCount, pt.token.line,</b>
&nbsp;          pt.token.linePos);
&nbsp;    }
<b class="fc">&nbsp;    if (childCount == 1) {</b>
<b class="fc">&nbsp;      ParseTree tmp = pt.getChild(PRIMARY_VALUE);</b>
<b class="fc">&nbsp;      switch (pt.getChild(0).getKind()) {</b>
&nbsp;        case V_BOOL:
<b class="fc">&nbsp;          vbool(ast, tmp, sTable);</b>
<b class="fc">&nbsp;          break;</b>
&nbsp;        case V_INT:
<b class="fc">&nbsp;          vint(ast, tmp, sTable);</b>
&nbsp;
<b class="fc">&nbsp;          break;</b>
&nbsp;        case IDENT:
<b class="fc">&nbsp;          ident(ast, tmp, sTable);</b>
&nbsp;
<b class="fc">&nbsp;          break;</b>
&nbsp;
&nbsp;        default:
&nbsp;          break;
&nbsp;      }
<b class="fc">&nbsp;    } else if (childCount == 3) {</b>
<b class="fc">&nbsp;      expression(ast, pt.getChild(PRIMARY_EXPRESSION), sTable);</b>
&nbsp;    } else {
<b class="fc">&nbsp;      functionCall(ast.insertSubTree(AstNodeKinds.FUNC_CALL, new Type(Types.FUNCTION, Types.UNKNOWN), pt.token.line,</b>
&nbsp;          pt.token.linePos), pt, sTable);
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  void vbool(AbstractSyntaxTree ast, ParseTree pt, SymbolTable sTable) {
<b class="fc">&nbsp;    ast.insertSubTree(AstNodeKinds.BOOLEAN, new Type(Types.BOOLEAN, Types.BOOLEAN), pt.token.line, pt.token.linePos,</b>
&nbsp;        pt.token.lexem);
&nbsp;
&nbsp;  }
&nbsp;
&nbsp;  void vint(AbstractSyntaxTree ast, ParseTree pt, SymbolTable sTable) {
<b class="fc">&nbsp;    ast.insertSubTree(AstNodeKinds.INTEGER, new Type(Types.INTEGER, Types.INTEGER), pt.token.line, pt.token.linePos,</b>
&nbsp;        pt.token.lexem);
&nbsp;  }
&nbsp;
&nbsp;  void ident(AbstractSyntaxTree ast, ParseTree pt, SymbolTable sTable) throws CompileError {
<b class="fc">&nbsp;    if (!sTable.has(pt.token.lexem)) {</b>
<b class="nc">&nbsp;      throw new UnknownIdentifierError(pt.token);</b>
&nbsp;    }
<b class="fc">&nbsp;    Symbol s = sTable.get(pt.token.lexem);</b>
<b class="fc">&nbsp;    ast.insertSubTree(AstNodeKinds.IDENT, s.getType(), pt.token.line, pt.token.linePos,</b>
&nbsp;        pt.token.lexem);
&nbsp;  }
&nbsp;
&nbsp;  boolean isChildCount1or3(ParseTree pt) {
<b class="fc">&nbsp;    return pt.getChildCount() == 1 || pt.getChildCount() == 3;</b>
&nbsp;  }
&nbsp;
&nbsp;  private void processProgram(ParseTree pt, AbstractSyntaxTree ast, SymbolTable sTable) throws CompileError {
<b class="fc">&nbsp;    for (int i = 0; i &lt; pt.getChildCount(); i++) {</b>
<b class="fc">&nbsp;      statement(pt.getChild(i), ast, sTable);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private void branch(ParseTree pt, AbstractSyntaxTree ast, SymbolTable sTable) throws CompileError {
<b class="fc">&nbsp;    ParseTree currentTree = pt.getChild(IF_STATEMENT);</b>
<b class="fc">&nbsp;    for (int i = IF_STATEMENT; currentTree.getKind() != TokenKind.CLOSE_PARANTHESES; currentTree = pt.getChild(++i)) {</b>
<b class="fc">&nbsp;      statement(currentTree, ast, sTable);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private void elseBranch(ParseTree pt, AbstractSyntaxTree ast, SymbolTable sTable) throws CompileError {
<b class="fc">&nbsp;    int elseIndex = pt.getChildIndex(TokenKind.ELSE);</b>
<b class="fc">&nbsp;    int firstStatementIndex = pt.getChildIndex(TokenKind.STATEMENT, elseIndex);</b>
&nbsp;    // empty else block
<b class="fc">&nbsp;    if (firstStatementIndex == -1) {</b>
&nbsp;      return;
&nbsp;    }
<b class="fc">&nbsp;    ParseTree currentTree = pt.getChild(firstStatementIndex);</b>
<b class="fc">&nbsp;    for (int i = firstStatementIndex; currentTree.getKind() != TokenKind.CLOSE_PARANTHESES; currentTree = pt</b>
<b class="fc">&nbsp;        .getChild(++i)) {</b>
<b class="fc">&nbsp;      statement(currentTree, ast, sTable);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private void statement(ParseTree pt, AbstractSyntaxTree ast, SymbolTable sTable) throws CompileError {
<b class="fc">&nbsp;    if (pt.getChildCount() == 0) {</b>
&nbsp;      return;
&nbsp;      
&nbsp;    }
<b class="fc">&nbsp;    TokenKind tk = pt.getChild(STATEMENT_TYPE).getKind();</b>
<b class="fc">&nbsp;    switch (tk) {</b>
&nbsp;      case IF:
<b class="fc">&nbsp;        AbstractSyntaxTree if_node = ast.insertSubTree(AstNodeKinds.IF, new Type(Types.VOID, Types.VOID),</b>
&nbsp;            pt.token.line,
&nbsp;            pt.token.linePos);
<b class="fc">&nbsp;        ParseTree if_condition = pt.getChild(IF_EXPRESSION);</b>
<b class="fc">&nbsp;        expression(if_node.insertSubTree(AstNodeKinds.CONDITION, new Type(Types.BOOLEAN, Types.VOID),</b>
&nbsp;            if_condition.token.line, if_condition.token.linePos), if_condition, sTable);
<b class="fc">&nbsp;        branch(pt,</b>
<b class="fc">&nbsp;            if_node.insertSubTree(AstNodeKinds.BRANCH, new Type(Types.VOID, Types.VOID), pt.token.line,</b>
&nbsp;                pt.token.linePos),
<b class="fc">&nbsp;            sTable.getScopedSymbolTable());</b>
&nbsp;
&nbsp;        // check if else branch is present and if the else branch is not empty
<b class="fc">&nbsp;        if (pt.getChildIndex(TokenKind.ELSE) != -1</b>
<b class="fc">&nbsp;            &amp;&amp; pt.getChildIndex(TokenKind.ELSE) != pt.getChildCount() - EMPTY_BLOCK_SIZE - 1) {</b>
<b class="fc">&nbsp;          elseBranch(pt,</b>
<b class="fc">&nbsp;              if_node.insertSubTree(AstNodeKinds.BRANCH, new Type(Types.VOID, Types.VOID), pt.token.line,</b>
&nbsp;                  pt.token.linePos),
<b class="fc">&nbsp;              sTable.getScopedSymbolTable());</b>
&nbsp;        }
&nbsp;        break;
&nbsp;      case WHILE:
<b class="fc">&nbsp;        AbstractSyntaxTree while_node = ast.insertSubTree(AstNodeKinds.WHILE, new Type(Types.VOID, Types.VOID),</b>
&nbsp;            pt.token.line,
&nbsp;            pt.token.linePos);
<b class="fc">&nbsp;        ParseTree while_condition = pt.getChild(WHILE_EXPRESSION);</b>
<b class="fc">&nbsp;        expression(while_node.insertSubTree(AstNodeKinds.CONDITION, new Type(Types.BOOLEAN, Types.VOID),</b>
&nbsp;            while_condition.token.line, while_condition.token.linePos), while_condition, sTable);
<b class="fc">&nbsp;        branch(pt,</b>
<b class="fc">&nbsp;            while_node.insertSubTree(AstNodeKinds.BRANCH, new Type(Types.VOID, Types.VOID), pt.token.line,</b>
&nbsp;                pt.token.linePos),
<b class="fc">&nbsp;            sTable.getScopedSymbolTable());</b>
&nbsp;
&nbsp;        // check if else branch is present and if the else branch is not empty
<b class="fc">&nbsp;        if (pt.getChildIndex(TokenKind.ELSE) != -1 &amp;&amp; pt.getChildIndex(TokenKind.ELSE) != pt.getChildCount() - 3) {</b>
<b class="nc">&nbsp;          elseBranch(pt,</b>
<b class="nc">&nbsp;              while_node.insertSubTree(AstNodeKinds.BRANCH, new Type(Types.VOID, Types.VOID), pt.token.line,</b>
&nbsp;                  pt.token.linePos),
<b class="nc">&nbsp;              sTable.getScopedSymbolTable());</b>
&nbsp;        }
&nbsp;        break;
&nbsp;      // Declarations
&nbsp;      case BOOL: {
<b class="fc">&nbsp;        ParseTree expression = pt.getChild(DECLARERATION_EXPRESSION);</b>
<b class="fc">&nbsp;        declaration(</b>
<b class="fc">&nbsp;            ast.insertSubTree(AstNodeKinds.DECLARATION, new Type(Types.VOID, Types.VOID), pt.token.line,</b>
&nbsp;                pt.token.linePos),
&nbsp;            pt, sTable);
<b class="fc">&nbsp;        assignment(</b>
<b class="fc">&nbsp;            ast.insertSubTree(AstNodeKinds.ASSIGNMENT, new Type(Types.BOOLEAN, Types.VOID),</b>
&nbsp;                expression.token.line, expression.token.linePos),
<b class="fc">&nbsp;            pt.removeFirst(), sTable);</b>
<b class="fc">&nbsp;        break;</b>
&nbsp;      }
&nbsp;      case INT: {
<b class="fc">&nbsp;        ParseTree expression = pt.getChild(DECLARERATION_EXPRESSION);</b>
<b class="fc">&nbsp;        declaration(</b>
<b class="fc">&nbsp;            ast.insertSubTree(AstNodeKinds.DECLARATION, new Type(Types.VOID, Types.VOID), pt.token.line,</b>
&nbsp;                pt.token.linePos),
&nbsp;            pt, sTable);
<b class="fc">&nbsp;        assignment(</b>
<b class="fc">&nbsp;            ast.insertSubTree(AstNodeKinds.ASSIGNMENT, new Type(Types.INTEGER, Types.VOID),</b>
&nbsp;                expression.token.line, expression.token.linePos),
<b class="fc">&nbsp;            pt.removeFirst(), sTable);</b>
<b class="fc">&nbsp;        break;</b>
&nbsp;      }
&nbsp;      // Assignment or function call
&nbsp;      case IDENT:
<b class="fc">&nbsp;        if (pt.getChildIndex(TokenKind.FUNC_CALL) != -1) {</b>
<b class="fc">&nbsp;          functionCall(ast.insertSubTree(AstNodeKinds.FUNC_CALL, new Type(Types.FUNCTION, Types.UNKNOWN),</b>
&nbsp;              pt.token.line, pt.token.linePos), pt, sTable);
&nbsp;
&nbsp;        } else {
<b class="fc">&nbsp;          assignment(</b>
<b class="fc">&nbsp;              ast.insertSubTree(AstNodeKinds.ASSIGNMENT, new Type(Types.VOID, Types.VOID),</b>
&nbsp;                  pt.token.line, pt.token.linePos),
&nbsp;              pt, sTable);
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        break;</b>
&nbsp;
&nbsp;      default:
<b class="nc">&nbsp;        throw new UnexpectedError(&quot;Unexpected statement type: &quot; + tk, pt.token.line, pt.token.linePos);</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private void functionCall(AbstractSyntaxTree ast, ParseTree pt, SymbolTable sTable) throws CompileError {
<b class="fc">&nbsp;    Token t = pt.getChild(0).token;</b>
<b class="fc">&nbsp;    Symbol s = sTable.get(t.lexem);</b>
<b class="fc">&nbsp;    if (s == null) {</b>
<b class="nc">&nbsp;      throw new UnknownIdentifierError(t);</b>
&nbsp;    }
<b class="fc">&nbsp;    ast.insertSubTree(AstNodeKinds.IDENT, s.getType(), t.line, t.linePos, t.lexem);</b>
<b class="fc">&nbsp;    int index = pt.getChild(1).getChildIndex(TokenKind.EXPRESSION);</b>
<b class="fc">&nbsp;    while (index != -1) {</b>
<b class="fc">&nbsp;      ParseTree expression = pt.getChild(1).getChild(index);</b>
<b class="fc">&nbsp;      expression(ast.insertSubTree(AstNodeKinds.PARAM, new Type(Types.VOID, Types.FUNCTION), expression.token.line,</b>
&nbsp;          expression.token.linePos), expression, sTable);
<b class="fc">&nbsp;      index = pt.getChild(1).getChildIndex(TokenKind.EXPRESSION, index + 1);</b>
&nbsp;
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;  }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-07-22 14:02</div>
</div>
</body>
</html>

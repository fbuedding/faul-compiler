


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > Emitter</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">emitter</a>
</div>

<h1>Coverage Summary for Class: Emitter (emitter)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Emitter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (45/45)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    89,3%
  </span>
  <span class="absValue">
    (284/318)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Emitter$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Emitter$Memory</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Emitter$Register</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    98%
  </span>
  <span class="absValue">
    (49/50)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    89,3%
  </span>
  <span class="absValue">
    (291/326)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package emitter;
&nbsp;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.LinkedHashMap;
&nbsp;import java.util.LinkedList;
&nbsp;import java.util.Map.Entry;
&nbsp;
&nbsp;import ast.AbstractSyntaxTree;
&nbsp;import ast.AstNodeKinds;
&nbsp;import ast.SymbolTable;
&nbsp;import error.CompileError;
&nbsp;import error.UnexpectedError;
&nbsp;import types.Types;
&nbsp;
&nbsp;/**
&nbsp; * Emmiter
&nbsp; */
&nbsp;public class Emitter {
<b class="nc">&nbsp;  public class Memory {</b>
&nbsp;  }
&nbsp;
<b class="fc">&nbsp;  enum Register {</b>
&nbsp;
<b class="fc">&nbsp;    T(&quot;t&quot;),</b>
<b class="fc">&nbsp;    S(&quot;s&quot;),</b>
<b class="fc">&nbsp;    V(&quot;v&quot;);</b>
&nbsp;
&nbsp;    public final String label;
&nbsp;
<b class="fc">&nbsp;    Register(String label) {</b>
<b class="fc">&nbsp;      this.label = label;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  StringBuilder code;
&nbsp;
&nbsp;  public StringBuilder getCode() {
<b class="fc">&nbsp;    return code;</b>
&nbsp;  }
&nbsp;
<b class="fc">&nbsp;  int tempCount = 0;</b>
<b class="fc">&nbsp;  int valCount = 0;</b>
<b class="fc">&nbsp;  int labelCount = 0;</b>
&nbsp;  AbstractSyntaxTree ast;
&nbsp;  SymbolTable sTable;
<b class="fc">&nbsp;  int wordLength = 0;</b>
&nbsp;
<b class="fc">&nbsp;  String memOffsetReg = &quot;&quot;;</b>
&nbsp;
&nbsp;  // Register lists for loading of variables
&nbsp;
<b class="fc">&nbsp;  final int maxLoaded = 8;</b>
<b class="fc">&nbsp;  LinkedHashMap&lt;Integer, String&gt; loaded = new LinkedHashMap&lt;&gt;();</b>
<b class="fc">&nbsp;  LinkedList&lt;String&gt; available = new LinkedList&lt;String&gt;(</b>
<b class="fc">&nbsp;      Arrays.asList(&quot;s0&quot;, &quot;s1&quot;, &quot;s2&quot;, &quot;s3&quot;, &quot;s4&quot;, &quot;s5&quot;, &quot;s6&quot;, &quot;s7&quot;));</b>
&nbsp;
&nbsp;  public Emitter(AbstractSyntaxTree ast, SymbolTable sTable) {
<b class="fc">&nbsp;    this(ast, sTable, 4, true);</b>
&nbsp;  }
&nbsp;
<b class="fc">&nbsp;  public Emitter(AbstractSyntaxTree ast, SymbolTable sTable, int wordLength, boolean has$Gp) {</b>
<b class="fc">&nbsp;    this.ast = ast;</b>
<b class="fc">&nbsp;    this.sTable = sTable;</b>
<b class="fc">&nbsp;    this.wordLength = wordLength;</b>
<b class="fc">&nbsp;    code = new StringBuilder();</b>
<b class="fc">&nbsp;    if (has$Gp) {</b>
<b class="fc">&nbsp;      memOffsetReg = &quot;$gp&quot;;</b>
&nbsp;    } else {
&nbsp;
<b class="nc">&nbsp;      memOffsetReg = &quot;$0&quot;;</b>
&nbsp;
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  public void generate() throws CompileError {
&nbsp;
<b class="fc">&nbsp;    generate(ast, sTable);</b>
&nbsp;  }
&nbsp;
&nbsp;  private void emitNop() {
&nbsp;
<b class="fc">&nbsp;    emit(&quot;nop&quot;);</b>
&nbsp;  }
&nbsp;
&nbsp;  private String declareVar(int address) {
&nbsp;    // if it&#39;s there it&#39;s out of scope
<b class="fc">&nbsp;    loaded.remove(address);</b>
<b class="fc">&nbsp;    String reg = &quot;&quot;;</b>
<b class="fc">&nbsp;    if (!available.isEmpty()) {</b>
<b class="fc">&nbsp;      reg = available.pop();</b>
&nbsp;    } else {
<b class="fc">&nbsp;      reg = freeLoadedVar();</b>
&nbsp;    }
<b class="fc">&nbsp;    loaded.putFirst(address, reg);</b>
<b class="fc">&nbsp;    emitComment(&quot;initializing %s with address %d&quot;, reg, address * wordLength);</b>
<b class="fc">&nbsp;    emitMv(reg, &quot;0&quot;);</b>
<b class="fc">&nbsp;    return reg;</b>
&nbsp;  }
&nbsp;
&nbsp;  private String loadVar(int address) {
<b class="fc">&nbsp;    String reg = loaded.remove(address);</b>
<b class="fc">&nbsp;    if (reg == null &amp;&amp; available.size() &gt; 0) {</b>
<b class="nc">&nbsp;      reg = available.pop();</b>
<b class="nc">&nbsp;      emitComment(&quot;loading %s from address %d&quot;, reg, address * wordLength);</b>
<b class="nc">&nbsp;      emitLw(reg, address);</b>
<b class="fc">&nbsp;    } else if (reg == null &amp;&amp; available.size() == 0) {</b>
<b class="fc">&nbsp;      reg = freeLoadedVar();</b>
<b class="fc">&nbsp;      emitLw(reg, address);</b>
&nbsp;    }
<b class="fc">&nbsp;    loaded.putFirst(address, reg);</b>
&nbsp;
<b class="fc">&nbsp;    return reg;</b>
&nbsp;
&nbsp;  }
&nbsp;
&nbsp;  private void assignVar(int address, String thatReg) {
<b class="fc">&nbsp;    String reg = loaded.remove(address);</b>
<b class="fc">&nbsp;    emitComment(&quot;Assgining reg %s with address %s&quot;, reg, address);</b>
<b class="fc">&nbsp;    if (reg == null &amp;&amp; !available.isEmpty()) {</b>
<b class="nc">&nbsp;      reg = available.pop();</b>
<b class="fc">&nbsp;    } else if (reg == null &amp;&amp; available.size() == 0) {</b>
<b class="fc">&nbsp;      reg = freeLoadedVar();</b>
<b class="fc">&nbsp;      emitLw(reg, address);</b>
&nbsp;    }
<b class="fc">&nbsp;    loaded.putFirst(address, reg);</b>
&nbsp;
<b class="fc">&nbsp;    emitMv(reg, thatReg);</b>
&nbsp;  }
&nbsp;
&nbsp;  private String freeLoadedVar() {
<b class="fc">&nbsp;    Entry&lt;Integer, String&gt; entry = loaded.pollLastEntry();</b>
<b class="fc">&nbsp;    String reg = entry.getValue();</b>
<b class="fc">&nbsp;    int address = entry.getKey();</b>
<b class="fc">&nbsp;    emitComment(&quot;unloading %s and storing in address %d&quot;, reg, address * wordLength);</b>
<b class="fc">&nbsp;    emitSw(reg, address);</b>
<b class="fc">&nbsp;    return reg;</b>
&nbsp;
&nbsp;  }
&nbsp;
&nbsp;  private void saveAllVars() {
<b class="fc">&nbsp;    emitComment(&quot;unloading all vars&quot;);</b>
<b class="fc">&nbsp;    while (!loaded.isEmpty()) {</b>
<b class="fc">&nbsp;      Entry&lt;Integer, String&gt; entry = loaded.pollLastEntry();</b>
<b class="fc">&nbsp;      String reg = entry.getValue();</b>
<b class="fc">&nbsp;      int address = entry.getKey();</b>
<b class="fc">&nbsp;      available.push(reg);</b>
<b class="fc">&nbsp;      emitComment(&quot;unloading %s and storing in address %d&quot;, reg, address * wordLength);</b>
<b class="fc">&nbsp;      emitSw(reg, address);</b>
&nbsp;
<b class="fc">&nbsp;    }</b>
&nbsp;  }
&nbsp;
&nbsp;  private void emitTab() {
<b class="fc">&nbsp;    code.append(&quot;\t&quot;);</b>
<b class="fc">&nbsp;    code.append(&quot;\t&quot;);</b>
&nbsp;  }
&nbsp;
&nbsp;  private void emit(String s) {
<b class="fc">&nbsp;    emitTab();</b>
<b class="fc">&nbsp;    code.append(s);</b>
<b class="fc">&nbsp;    code.append(&quot;\n&quot;);</b>
&nbsp;  }
&nbsp;
&nbsp;  private void emitLabel(String label) {
<b class="fc">&nbsp;    code.append(String.format(&quot;%s:&quot;, label));</b>
<b class="fc">&nbsp;    code.append(&quot;\n&quot;);</b>
&nbsp;  }
&nbsp;
&nbsp;  private void emitExit() {
<b class="fc">&nbsp;    emitComment(&quot;Exit&quot;);</b>
&nbsp;
<b class="fc">&nbsp;    emit(&quot;li $v0, 10&quot;);</b>
&nbsp;
<b class="fc">&nbsp;    emit(&quot;syscall&quot;);</b>
&nbsp;  }
&nbsp;
&nbsp;  private void emitComment(String s, Object... args) {
<b class="fc">&nbsp;    code.append(&quot;# &quot; + String.format(s, args));</b>
<b class="fc">&nbsp;    code.append(&quot;\n&quot;);</b>
&nbsp;  }
&nbsp;
&nbsp;  private void emit(String s, Object... args) {
<b class="fc">&nbsp;    emitTab();</b>
<b class="fc">&nbsp;    code.append(String.format(s, args));</b>
<b class="fc">&nbsp;    code.append(&quot;\n&quot;);</b>
&nbsp;  }
&nbsp;
&nbsp;  private void emitMv(String reg, String reg2) {
&nbsp;
<b class="fc">&nbsp;    emit(&quot;move $%s, $%s&quot;, reg, reg2);</b>
&nbsp;  }
&nbsp;
&nbsp;  private void emitStackPush(String reg) {
&nbsp;
<b class="fc">&nbsp;    emit(&quot;addi $sp, $sp, -4&quot;);</b>
&nbsp;
<b class="fc">&nbsp;    emit(&quot;sw $%s, 0($sp)&quot;, reg);</b>
&nbsp;
&nbsp;  }
&nbsp;
&nbsp;  private void emitStackPop(String reg) {
&nbsp;
<b class="fc">&nbsp;    emit(&quot;lw $%s, 0($sp)&quot;, reg);</b>
&nbsp;
<b class="fc">&nbsp;    emit(&quot;addi $sp, $sp, 4&quot;);</b>
&nbsp;  }
&nbsp;
&nbsp;  private void emitLw(String reg, int address) {
&nbsp;
<b class="fc">&nbsp;    emit(&quot;lw $%s, %d(%s)&quot;, reg, address * wordLength, memOffsetReg);</b>
&nbsp;  }
&nbsp;
&nbsp;  private void emitSw(String reg, int address) {
&nbsp;
<b class="fc">&nbsp;    emit(&quot;sw $%s, %d(%s)&quot;, reg, address * wordLength, memOffsetReg);</b>
&nbsp;  }
&nbsp;
&nbsp;  private void emitPrint() {
<b class="fc">&nbsp;    emitLabel(&quot;print&quot;);</b>
<b class="fc">&nbsp;    emitStackPush(&quot;ra&quot;);</b>
<b class="fc">&nbsp;    emit(&quot;li $v0, 1&quot;);</b>
<b class="fc">&nbsp;    emit(&quot;syscall&quot;);</b>
<b class="fc">&nbsp;    emitNop();</b>
<b class="fc">&nbsp;    emitStackPop(&quot;ra&quot;);</b>
&nbsp;
<b class="fc">&nbsp;    emit(&quot;jr $ra&quot;);</b>
<b class="fc">&nbsp;    emitNop();</b>
&nbsp;  }
&nbsp;
&nbsp;  private void emitReadI() {
<b class="fc">&nbsp;    emitLabel(&quot;readI&quot;);</b>
<b class="fc">&nbsp;    emitStackPush(&quot;ra&quot;);</b>
<b class="fc">&nbsp;    emit(&quot;li $v0, 5&quot;);</b>
<b class="fc">&nbsp;    emit(&quot;syscall&quot;);</b>
<b class="fc">&nbsp;    emitNop();</b>
<b class="fc">&nbsp;    emitStackPop(&quot;ra&quot;);</b>
<b class="fc">&nbsp;    emit(&quot;jr $ra&quot;);</b>
<b class="fc">&nbsp;    emitNop();</b>
&nbsp;  }
&nbsp;
&nbsp;  private void emitReadB() {
<b class="fc">&nbsp;    emitLabel(&quot;readB&quot;);</b>
<b class="fc">&nbsp;    emitStackPush(&quot;ra&quot;);</b>
<b class="fc">&nbsp;    emit(&quot;li $v0, 5&quot;);</b>
<b class="fc">&nbsp;    emit(&quot;syscall&quot;);</b>
<b class="fc">&nbsp;    emitNop();</b>
<b class="fc">&nbsp;    emit(&quot;andi $v0, $v0, 1&quot;);</b>
<b class="fc">&nbsp;    emitStackPop(&quot;ra&quot;);</b>
<b class="fc">&nbsp;    emit(&quot;jr $ra&quot;);</b>
<b class="fc">&nbsp;    emitNop();</b>
&nbsp;  }
&nbsp;
&nbsp;  private void emitInitVar(AbstractSyntaxTree ast) {
<b class="fc">&nbsp;    int address = Integer.parseInt(ast.value);</b>
&nbsp;    // loadWordIntoReg(address);
&nbsp;    // emit(&quot;sw $0, %d(%s)&quot;, address, memOffsetReg);
<b class="fc">&nbsp;    declareVar(address);</b>
&nbsp;
&nbsp;  }
&nbsp;
&nbsp;  private void generate(AbstractSyntaxTree ast, SymbolTable sTable) throws CompileError {
<b class="fc">&nbsp;    branch(ast, sTable, &quot;main&quot;);</b>
<b class="fc">&nbsp;    saveAllVars();</b>
<b class="fc">&nbsp;    emitExit();</b>
&nbsp;
<b class="fc">&nbsp;    emitReadI();</b>
<b class="fc">&nbsp;    emitReadB();</b>
<b class="fc">&nbsp;    emitPrint();</b>
<b class="fc">&nbsp;    emitLabel(&quot;exit&quot;);</b>
<b class="fc">&nbsp;    emitExit();</b>
&nbsp;  }
&nbsp;
&nbsp;  private void branch(AbstractSyntaxTree ast, SymbolTable sTable, String label) throws CompileError {
<b class="fc">&nbsp;    emitLabel(label);</b>
<b class="fc">&nbsp;    branch(ast, sTable);</b>
&nbsp;  }
&nbsp;
&nbsp;  private void branch(AbstractSyntaxTree ast, SymbolTable sTable) throws CompileError {
&nbsp;    // saveAllVars();
<b class="fc">&nbsp;    for (AbstractSyntaxTree currentAst : ast.children) {</b>
<b class="fc">&nbsp;      switch (currentAst.kind) {</b>
&nbsp;        case DECLARATION:
<b class="fc">&nbsp;          emitInitVar(currentAst.getChild(AstNodeKinds.ADDRESS));</b>
<b class="fc">&nbsp;          break;</b>
&nbsp;        case ASSIGNMENT:
<b class="fc">&nbsp;          assignment(currentAst, sTable);</b>
<b class="fc">&nbsp;          break;</b>
&nbsp;        case IF:
<b class="fc">&nbsp;          ifNode(currentAst, sTable);</b>
<b class="fc">&nbsp;          break;</b>
&nbsp;        case WHILE:
<b class="fc">&nbsp;          whileNode(currentAst, sTable);</b>
&nbsp;
<b class="fc">&nbsp;          break;</b>
&nbsp;        case FUNC_CALL:
<b class="fc">&nbsp;          funcCall(currentAst, sTable);</b>
<b class="fc">&nbsp;          break;</b>
&nbsp;        default:
<b class="nc">&nbsp;          throw new UnexpectedError(&quot;Unknown or unimplemented statement kind &quot; + currentAst.kind, currentAst.line,</b>
&nbsp;              currentAst.linePos);
&nbsp;      }
<b class="fc">&nbsp;    }</b>
&nbsp;    // saveAllVars();
&nbsp;  }
&nbsp;
&nbsp;  private String funcCall(AbstractSyntaxTree ast, SymbolTable sTable) throws UnexpectedError {
<b class="fc">&nbsp;    String ident = ast.getChild(AstNodeKinds.IDENT).value;</b>
<b class="fc">&nbsp;    String label = sTable.getLabel(ident);</b>
<b class="fc">&nbsp;    if (label == null) {</b>
<b class="nc">&nbsp;      throw new UnexpectedError(&quot;Function undefined&quot;, ast.line, ast.linePos);</b>
&nbsp;    }
<b class="fc">&nbsp;    String[] paramRegs = { &quot;a0&quot;, &quot;a1&quot;, &quot;a2&quot;, &quot;a3&quot; };</b>
<b class="fc">&nbsp;    for (int i = 1; i &lt; ast.getChildrenCount(); i++) {</b>
<b class="fc">&nbsp;      String reg = expression(ast.getChild(i).getChild(0), sTable);</b>
<b class="fc">&nbsp;      decrementRegCounter(reg);</b>
&nbsp;      try {
<b class="fc">&nbsp;        emitMv(paramRegs[i - 1], reg);</b>
<b class="nc">&nbsp;      } catch (IndexOutOfBoundsException e) {</b>
<b class="nc">&nbsp;        throw new UnexpectedError(&quot;Function regs out of bounce (only parameters are possible)&quot;, ast.line, ast.linePos);</b>
<b class="fc">&nbsp;      }</b>
&nbsp;    }
<b class="fc">&nbsp;    emit(&quot;jal %s&quot;, label);</b>
<b class="fc">&nbsp;    emitNop();</b>
<b class="fc">&nbsp;    return &quot;v0&quot;;</b>
&nbsp;  }
&nbsp;
&nbsp;  private void whileNode(AbstractSyntaxTree ast, SymbolTable sTable) throws CompileError {
<b class="fc">&nbsp;    if (ast.getChildrenCount() != 2) {</b>
<b class="nc">&nbsp;      throw new UnexpectedError(&quot;While is empty&quot;, ast.line, ast.linePos);</b>
&nbsp;    }
<b class="fc">&nbsp;    String endLabel = getLabel();</b>
<b class="fc">&nbsp;    AbstractSyntaxTree condition = ast.getChild(AstNodeKinds.CONDITION);</b>
<b class="fc">&nbsp;    if (condition == null || condition.getChildrenCount() == 0) {</b>
<b class="nc">&nbsp;      throw new UnexpectedError(&quot;While-Condition is empty&quot;, ast.line, ast.linePos);</b>
&nbsp;    }
<b class="fc">&nbsp;    emitComment(&quot;While start&quot;);</b>
<b class="fc">&nbsp;    String loopLabel = getLabel();</b>
<b class="fc">&nbsp;    emitLabel(loopLabel);</b>
<b class="fc">&nbsp;    String conditionReg = expression(condition.getChild(0), sTable);</b>
<b class="fc">&nbsp;    emit(&quot;beqz $%s, %s&quot;, conditionReg, endLabel);</b>
<b class="fc">&nbsp;    emitNop();</b>
<b class="fc">&nbsp;    branch(ast.getChild(1), sTable.popScopedSymbolTable());</b>
<b class="fc">&nbsp;    emit(&quot;b %s&quot;, loopLabel);</b>
<b class="fc">&nbsp;    emitNop();</b>
<b class="fc">&nbsp;    emitComment(&quot;While end&quot;);</b>
<b class="fc">&nbsp;    emitLabel(endLabel);</b>
&nbsp;  }
&nbsp;
&nbsp;  private void ifNode(AbstractSyntaxTree ast, SymbolTable sTable) throws CompileError {
<b class="fc">&nbsp;    String endLabel = getLabel();</b>
<b class="fc">&nbsp;    AbstractSyntaxTree condition = ast.getChild(AstNodeKinds.CONDITION);</b>
<b class="fc">&nbsp;    if (condition == null) {</b>
<b class="nc">&nbsp;      throw new UnexpectedError(&quot;If-Condition is empty&quot;, ast.line, ast.linePos);</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    emitComment(&quot;If start&quot;);</b>
<b class="fc">&nbsp;    String conditionReg = expression(condition.getChild(0), sTable);</b>
<b class="fc">&nbsp;    switch (ast.getChildrenCount()) {</b>
&nbsp;      case 2:
&nbsp;        // no else branch
<b class="fc">&nbsp;        emit(&quot;beqz $%s, %s&quot;, conditionReg, endLabel);</b>
<b class="fc">&nbsp;        emitNop();</b>
<b class="fc">&nbsp;        branch(ast.getChild(1), sTable.popScopedSymbolTable());</b>
<b class="fc">&nbsp;        break;</b>
&nbsp;      case 3:
<b class="fc">&nbsp;        String elseLabel = getLabel();</b>
<b class="fc">&nbsp;        emit(&quot;beqz $%s, %s&quot;, conditionReg, elseLabel);</b>
<b class="fc">&nbsp;        emitNop();</b>
<b class="fc">&nbsp;        branch(ast.getChild(1), sTable.popScopedSymbolTable());</b>
<b class="fc">&nbsp;        emit(&quot;b %s&quot;, endLabel);</b>
<b class="fc">&nbsp;        emitNop();</b>
<b class="fc">&nbsp;        emitComment(&quot;else start&quot;);</b>
<b class="fc">&nbsp;        emitLabel(elseLabel);</b>
<b class="fc">&nbsp;        branch(ast.getChild(2), sTable.popScopedSymbolTable());</b>
<b class="fc">&nbsp;        break;</b>
&nbsp;      default:
&nbsp;    }
<b class="fc">&nbsp;    emitComment(&quot;If end&quot;);</b>
<b class="fc">&nbsp;    emitLabel(endLabel);</b>
&nbsp;  }
&nbsp;
&nbsp;  private String getLabel() {
<b class="fc">&nbsp;    return String.format(&quot;label_%d&quot;, labelCount++);</b>
&nbsp;  }
&nbsp;
&nbsp;  private void assignment(AbstractSyntaxTree ast, SymbolTable sTable) throws UnexpectedError {
<b class="fc">&nbsp;    String ident = ast.getChild(AstNodeKinds.IDENT).value;</b>
<b class="fc">&nbsp;    AbstractSyntaxTree secondChild = ast.getChild(1);</b>
<b class="fc">&nbsp;    int address = sTable.getAddress(ident);</b>
&nbsp;    String reg;
&nbsp;    // Special case, if the second child is a value we don&#39;t need a temporary reg
<b class="fc">&nbsp;    if (isVal(secondChild)) {</b>
<b class="fc">&nbsp;      reg = loadVar(address);</b>
<b class="fc">&nbsp;      switch (secondChild.kind) {</b>
&nbsp;        case BOOLEAN:
<b class="nc">&nbsp;          if (secondChild.value.equals(&quot;true&quot;)) {</b>
<b class="nc">&nbsp;            emit(&quot;addi $%s, $0, 1&quot;, reg);</b>
&nbsp;          } else {
<b class="nc">&nbsp;            emit(&quot;addi $%s, $0, 0&quot;, reg);</b>
&nbsp;          }
<b class="nc">&nbsp;          break;</b>
&nbsp;        case INTEGER:
<b class="fc">&nbsp;          int val = Integer.parseInt(secondChild.value);</b>
<b class="fc">&nbsp;          emit(&quot;addi $%s, $0, %d&quot;, reg, val);</b>
<b class="fc">&nbsp;          break;</b>
&nbsp;
&nbsp;        default:
&nbsp;          break;
&nbsp;      }
&nbsp;      // early return since var is already assigned
&nbsp;      return;
&nbsp;    }
<b class="fc">&nbsp;    reg = expression(secondChild, sTable);</b>
<b class="fc">&nbsp;    decrementRegCounter(reg);</b>
<b class="fc">&nbsp;    assignVar(address, reg);</b>
&nbsp;    // emit(&quot;sw $%s, %d(%s)&quot;, reg, address, memOffsetReg);
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * @param ast
&nbsp;   * @param sTable
&nbsp;   * @return register with the result in it
&nbsp;   * @throws UnexpectedError
&nbsp;   */
&nbsp;  private String binOp(AbstractSyntaxTree ast, SymbolTable sTable) throws UnexpectedError {
<b class="fc">&nbsp;    AbstractSyntaxTree leftChild = ast.getChild(0);</b>
<b class="fc">&nbsp;    AbstractSyntaxTree rightChild = ast.getChild(1);</b>
<b class="fc">&nbsp;    String leftReg = &quot;&quot;, rightReg = &quot;&quot;;</b>
<b class="fc">&nbsp;    if (leftChild.depth() &gt;= rightChild.depth()) {</b>
<b class="fc">&nbsp;      leftReg = expression(leftChild, sTable);</b>
<b class="fc">&nbsp;      rightReg = expression(rightChild, sTable);</b>
&nbsp;    } else {
<b class="fc">&nbsp;      rightReg = expression(rightChild, sTable);</b>
<b class="fc">&nbsp;      leftReg = expression(leftChild, sTable);</b>
&nbsp;    }
<b class="fc">&nbsp;    decrementRegCounter(leftReg, rightReg);</b>
<b class="fc">&nbsp;    String tempReg = getReg(Register.T);</b>
<b class="fc">&nbsp;    switch (ast.getKind()) {</b>
&nbsp;      case PLUS:
<b class="fc">&nbsp;        emit(&quot;add $%s, $%s, $%s&quot;, tempReg, leftReg, rightReg);</b>
<b class="fc">&nbsp;        break;</b>
&nbsp;      case MINUS:
<b class="fc">&nbsp;        emit(&quot;sub $%s, $%s, $%s&quot;, tempReg, leftReg, rightReg);</b>
<b class="fc">&nbsp;        break;</b>
&nbsp;      case MUL:
<b class="fc">&nbsp;        emit(&quot;mul $%s, $%s, $%s&quot;, tempReg, leftReg, rightReg);</b>
<b class="fc">&nbsp;        break;</b>
&nbsp;      case DIV:
<b class="fc">&nbsp;        emit(&quot;div $%s, $%s, $%s&quot;, tempReg, leftReg, rightReg);</b>
<b class="fc">&nbsp;        break;</b>
&nbsp;      case MOD:
<b class="fc">&nbsp;        emitComment(&quot;Modulo&quot;);</b>
<b class="fc">&nbsp;        emit(&quot;div $%s, $%s&quot;, leftReg, rightReg);</b>
<b class="fc">&nbsp;        emit(&quot;mfhi $%s&quot;, tempReg);</b>
<b class="fc">&nbsp;        break;</b>
&nbsp;      case EQEQ:
<b class="fc">&nbsp;        emitComment(&quot;Equals&quot;);</b>
<b class="fc">&nbsp;        emit(&quot;seq $%s, $%s, $%s&quot;, tempReg, leftReg, rightReg);</b>
<b class="fc">&nbsp;        break;</b>
&nbsp;      case NOTEQ:
<b class="fc">&nbsp;        emitComment(&quot;Not equals&quot;);</b>
<b class="fc">&nbsp;        emit(&quot;sne $%s, $%s, $%s&quot;, tempReg, leftReg, rightReg);</b>
<b class="fc">&nbsp;        break;</b>
&nbsp;      case GT:
<b class="nc">&nbsp;        emitComment(&quot;Greater than&quot;);</b>
<b class="nc">&nbsp;        emit(&quot;sgt $%s, $%s, $%s&quot;, tempReg, leftReg, rightReg);</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case GTEQ:
<b class="nc">&nbsp;        emitComment(&quot;Greater than equal&quot;);</b>
<b class="nc">&nbsp;        emit(&quot;sge $%s, $%s, $%s&quot;, tempReg, leftReg, rightReg);</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case LT:
<b class="fc">&nbsp;        emitComment(&quot;Less than&quot;);</b>
<b class="fc">&nbsp;        emit(&quot;slt $%s, $%s, $%s&quot;, tempReg, leftReg, rightReg);</b>
<b class="fc">&nbsp;        break;</b>
&nbsp;      case LTEQ:
<b class="fc">&nbsp;        emitComment(&quot;Less than equals&quot;);</b>
<b class="fc">&nbsp;        emit(&quot;sle $%s, $%s, $%s&quot;, tempReg, leftReg, rightReg);</b>
<b class="fc">&nbsp;        break;</b>
&nbsp;
&nbsp;      // Das ergebnis ist dasselbe, daher zusammen gefasst
&nbsp;      case LOR, OR:
<b class="nc">&nbsp;        emit(&quot;or $%s, $%s, $%s&quot;, tempReg, leftReg, rightReg);</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;      case LAND, AND:
<b class="nc">&nbsp;        emit(&quot;and $%s, $%s, $%s&quot;, tempReg, leftReg, rightReg);</b>
<b class="nc">&nbsp;        break;</b>
&nbsp;
&nbsp;      default:
&nbsp;        break;
&nbsp;    }
<b class="fc">&nbsp;    return tempReg;</b>
&nbsp;  }
&nbsp;
&nbsp;  private String unOp(AbstractSyntaxTree ast, SymbolTable sTable) throws UnexpectedError {
<b class="fc">&nbsp;    String reg = expression(ast.getChild(0), sTable);</b>
<b class="fc">&nbsp;    decrementRegCounter(reg);</b>
<b class="fc">&nbsp;    String tempReg = getReg(Register.T);</b>
<b class="fc">&nbsp;    switch (ast.getKind()) {</b>
&nbsp;      case NOT:
<b class="fc">&nbsp;        emit(&quot;nor $%s, $%s, $%&lt;s&quot;, tempReg, reg);</b>
<b class="fc">&nbsp;        if (ast.type.checkType(Types.BOOLEAN)) {</b>
<b class="fc">&nbsp;          emit(&quot;andi $%s, $%&lt;s, 1&quot;, tempReg);</b>
&nbsp;        }
&nbsp;        break;
&nbsp;      case NEG:
<b class="fc">&nbsp;        emitComment(&quot;negating $s&quot;, reg);</b>
<b class="fc">&nbsp;        emit(&quot;sub $%s, $0, $%s&quot;, tempReg, reg);</b>
&nbsp;
<b class="fc">&nbsp;        break;</b>
&nbsp;
&nbsp;      default:
&nbsp;        break;
&nbsp;    }
<b class="fc">&nbsp;    return tempReg;</b>
&nbsp;  }
&nbsp;
&nbsp;  private String id(AbstractSyntaxTree ast, SymbolTable sTable) {
<b class="fc">&nbsp;    int address = sTable.getAddress(ast.value);</b>
<b class="fc">&nbsp;    String reg = loadVar(address);</b>
<b class="fc">&nbsp;    return reg;</b>
&nbsp;  }
&nbsp;
&nbsp;  private String expression(AbstractSyntaxTree ast, SymbolTable sTable) throws UnexpectedError {
&nbsp;    String reg;
<b class="fc">&nbsp;    if (isBinOp(ast)) {</b>
<b class="fc">&nbsp;      reg = binOp(ast, sTable);</b>
<b class="fc">&nbsp;    } else if (isUnOp(ast)) {</b>
<b class="fc">&nbsp;      reg = unOp(ast, sTable);</b>
<b class="fc">&nbsp;    } else if (isId(ast)) {</b>
<b class="fc">&nbsp;      reg = id(ast, sTable);</b>
<b class="fc">&nbsp;    } else if (isVal(ast)) {</b>
<b class="fc">&nbsp;      reg = val(ast, sTable);</b>
<b class="fc">&nbsp;    } else if (isFunc(ast)) {</b>
<b class="fc">&nbsp;      reg = funcCall(ast, sTable);</b>
&nbsp;    } else {
<b class="nc">&nbsp;      throw new UnexpectedError(&quot;Unknown operator: &quot; + ast.value, ast.line, ast.linePos);</b>
&nbsp;    }
<b class="fc">&nbsp;    return reg;</b>
&nbsp;  }
&nbsp;
&nbsp;  private boolean isFunc(AbstractSyntaxTree ast) {
<b class="fc">&nbsp;    return ast.kind == AstNodeKinds.FUNC_CALL;</b>
&nbsp;  }
&nbsp;
&nbsp;  private String val(AbstractSyntaxTree ast, SymbolTable sTable) {
<b class="fc">&nbsp;    String reg = getReg(Register.T);</b>
<b class="fc">&nbsp;    String val = ast.value;</b>
<b class="fc">&nbsp;    if (val.equals(&quot;true&quot;)) {</b>
<b class="fc">&nbsp;      val = &quot;1&quot;;</b>
<b class="fc">&nbsp;    } else if (val.equals(&quot;false&quot;)) {</b>
<b class="fc">&nbsp;      val = &quot;0&quot;;</b>
&nbsp;    }
<b class="fc">&nbsp;    emitComment(&quot;Loading value %s&quot;, val);</b>
<b class="fc">&nbsp;    emit(&quot;li $%s, %s&quot;, reg, val);</b>
<b class="fc">&nbsp;    return reg;</b>
&nbsp;
&nbsp;  }
&nbsp;
&nbsp;  private void decrementRegCounter(String... regs) {
<b class="fc">&nbsp;    for (String reg : regs) {</b>
<b class="fc">&nbsp;      if (reg.startsWith(&quot;t&quot;)) {</b>
<b class="fc">&nbsp;        tempCount--;</b>
<b class="fc">&nbsp;      } else if (reg.startsWith(&quot;s&quot;)) {</b>
&nbsp;        // save register werden nur unloaded wenn platz ben√∂tigt wird
<b class="fc">&nbsp;      } else if (reg.startsWith(&quot;v&quot;)) {</b>
<b class="fc">&nbsp;        valCount--;</b>
&nbsp;      }
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private String getReg(Register r) {
<b class="fc">&nbsp;    switch (r) {</b>
&nbsp;      case T:
<b class="fc">&nbsp;        return String.format(&quot;%s%d&quot;, r.label, tempCount++);</b>
&nbsp;      case S:
<b class="nc">&nbsp;        throw new Error(&quot;Saved registers are LRU cached organized&quot;);</b>
&nbsp;
&nbsp;      case V:
<b class="nc">&nbsp;        return String.format(&quot;%s%d&quot;, r.label, valCount++);</b>
&nbsp;      default:
<b class="nc">&nbsp;        throw new Error(&quot;Should not happen&quot;);</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;  }
&nbsp;
&nbsp;  private boolean isId(AbstractSyntaxTree ast) {
<b class="fc">&nbsp;    if (ast == null) {</b>
<b class="nc">&nbsp;      return false;</b>
&nbsp;    }
<b class="fc">&nbsp;    AstNodeKinds kind = ast.kind;</b>
<b class="fc">&nbsp;    return kind == AstNodeKinds.IDENT;</b>
&nbsp;  }
&nbsp;
&nbsp;  private boolean isVal(AbstractSyntaxTree ast) {
<b class="fc">&nbsp;    if (ast == null) {</b>
<b class="nc">&nbsp;      return false;</b>
&nbsp;    }
<b class="fc">&nbsp;    AstNodeKinds kind = ast.kind;</b>
<b class="fc">&nbsp;    return kind == AstNodeKinds.INTEGER</b>
&nbsp;        || kind == AstNodeKinds.BOOLEAN;
&nbsp;  }
&nbsp;
&nbsp;  private boolean isUnOp(AbstractSyntaxTree ast) {
<b class="fc">&nbsp;    if (ast == null) {</b>
<b class="nc">&nbsp;      return false;</b>
&nbsp;    }
<b class="fc">&nbsp;    AstNodeKinds kind = ast.kind;</b>
<b class="fc">&nbsp;    return kind == AstNodeKinds.NOT</b>
&nbsp;        || kind == AstNodeKinds.NEG;
&nbsp;  }
&nbsp;
&nbsp;  private boolean isBinOp(AbstractSyntaxTree ast) {
<b class="fc">&nbsp;    if (ast == null) {</b>
<b class="nc">&nbsp;      return false;</b>
&nbsp;    }
<b class="fc">&nbsp;    AstNodeKinds kind = ast.kind;</b>
<b class="fc">&nbsp;    return kind == AstNodeKinds.EQEQ</b>
&nbsp;        || kind == AstNodeKinds.NOTEQ
&nbsp;        || kind == AstNodeKinds.LT
&nbsp;        || kind == AstNodeKinds.LTEQ
&nbsp;        || kind == AstNodeKinds.GT
&nbsp;        || kind == AstNodeKinds.GTEQ
&nbsp;        || kind == AstNodeKinds.LOR
&nbsp;        || kind == AstNodeKinds.LAND
&nbsp;        || kind == AstNodeKinds.OR
&nbsp;        || kind == AstNodeKinds.AND
&nbsp;        || kind == AstNodeKinds.PLUS
&nbsp;        || kind == AstNodeKinds.MINUS
&nbsp;        || kind == AstNodeKinds.MUL
&nbsp;        || kind == AstNodeKinds.DIV
&nbsp;        || kind == AstNodeKinds.MOD;
&nbsp;
&nbsp;  }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-07-22 13:49</div>
</div>
</body>
</html>
